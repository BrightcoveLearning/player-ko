
---
title: 카탈로그 검색 아키텍처
parent: References 
---

<article class="bcls-article">
  <h1>카탈로그 검색 아키텍처</h1>
  <summary>이 항목에서는 카탈로그 검색 기술을위한 Brightcove의 아키텍처에 대해 알아 봅니다.</summary>
  <section class="bcls-section">
    <h2 id="Overview">개요</h2>
    <p >2019년 4월부터 카탈로그 검색 기능이 Elasticsearch로 업그레이드되었습니다. 이 업그레이드는 많은 이점을 제공합니다. 그 중 가장 중요한 것은 향상된 관련성 및 정확성, 극적으로 향상된 성능입니다. 응답 시간이 훨씬 더 일관되고 일반적으로 두 배 빠릅니다. 이 새로운 기능은 CMS API, Playback API, Studio 대화형 검색 및 카탈로그 검색 방법에 영향을 미칩니다.</p>
    <p >Brightcove는 Elasticsearch 결과의 일관성을 유지하기 위해 상당한 노력을 투자했지만 차이점이 있으며 검색 결과에 대한 특정 종속성을 코딩한 경우 통합이 예상대로 작동하지 않을 수 있는 약간의 가능성이 있습니다.</p>
  </section>
  <section class="bcls-section">
    <h2 id="Search_Result_Differences_and_Impact">검색 결과의 차이점 및 영향</h2>
    <p >잠재적인 영향을 연구하면서 Brightcove는 검색의 90% 이상이 반환된 결과 수와 관련하여 일치하는 결과를 반환한다는 사실을 발견했습니다. 이는 예상 결과가 API 통합에 문제를 일으킬 만큼 충분히 다르지 않아야 함을 나타내는 지표입니다.</p>
    <figure class="bcls-figure"><img class="bcls-image" alt="comparison" src="/assets/images/references/catalog-search/comparison.png" /></figure>
    <p >이 그래프는 두 시스템 간의 결과 수와 정확히 일치하는 검색 결과 수를 파란색으로 표시하고 숫자가 다른 시스템의 결과 수를 빨간색으로 표시합니다.</p>
    <p >출시의 일환으로 모든 기본 검색, 빈 문자열에 대한 검색은 이미 Elasticsearch에서 몇 개월 전부터 제공되어 왔습니다. 따라서 사용자는 이미 Elasticsearch 결과를 문제 없이 보고 사용하고 있습니다.</p>
    <p >그러나 이러한 종류의 비교에서 배울 수 있는 것에는 한계가 있습니다. 기껏해야 특정 검색의 의도를 추론할 수 있을 뿐이며 카탈로그 데이터는 유동적입니다.</p>
  </section>
  <section class="bcls-section">
    <h2 id="Known_Differences">알려진 차이점</h2>
    <p >아래의 차이점은 대부분 근본적이거나 검색 결과를 광범위하게 분석한 후 결정한 결과이므로 완전히 제거할 수 없습니다.</p>
    <h3>형태소 분석</h3>
    <p ><a href="https://en.wikipedia.org/wiki/Stemming">형태소 분석</a>변형된(또는 때때로 파생된) 단어를 해당 단어로 줄이는 과정입니다. <a href="https://en.wikipedia.org/wiki/Word_stem">단어 줄기</a> , 기본 또는<a href="https://en.wikipedia.org/wiki/Root_(linguistics)">뿌리</a>형식 — 일반적으로 서면 단어 형식입니다.</p>
    <p >줄기에서 작동하는 영어용 형태소 분석기 <em>고양이</em> 그러한 식별해야<a href="https://en.wikipedia.org/wiki/String_literal">문자열</a>같이 <em>고양이</em>, <em>고양이 같은</em> 과 <em>캐티</em>. 형태소 분석 알고리즘은 단어를 줄일 수도 있습니다. <em>어업</em>, <em>낚시</em> 과 <em>어부</em> 줄기에 <em>생선</em>. 줄기는 단어일 필요가 없습니다. 예를 들어 Porter 알고리즘은 <em>다투다</em>, <em>주장</em>, <em>주장하다</em>, <em>논쟁</em> 과 <em>아르고스</em> 줄기에 <em>아르구</em>.</p>
    <p >우리의 기존 검색은 Lancaster(Paice/Husk) 형태소 분석기를 사용합니다. 이 알고리즘은 일반적으로 지나치게 공격적인 것으로 간주됩니다. <em>거룻배</em> 과 <em>빛</em> Lancaster에서는 같은 용어로 간주됩니다.</p>
    <p >Elasticsearch는 업계에서 광범위하게 채택되고 일반적으로 상당한 개선으로 간주되는 보다 최근의 훨씬 덜 공격적인 알고리즘(Porter2)을 사용합니다(Lancaster는 현재 드물다). 형태소 분석기의 변경은 잠재적으로 상당한(~35%) 검색 비율에 영향을 미칩니다. <strong> ~ 할 것이다</strong>달라져, 그저 그들이<strong> ~ 할 것 같다</strong>다를 수 있습니다. 그러나 일반적으로 이것은 더 나은 방향이어야 합니다. 즉, 일부 고객은 이전 행동에 의존할 수 있습니다.</p>
    <h3>관련성</h3>
    <p >우리의 기존 검색은 더 엄격한 TF 정규화를 가지고 있는 것 같습니다. 이로 인해 더 큰 필드에서 발견되는 용어에 대해 다른 관련성 정렬이 발생합니다(즉, 기존의 경우 일치 항목이 문서의 길이에 비해 더 작기 때문에 용어에 더 적은 가중치를 주기 때문에 덜 관련성이 있는 것으로 간주합니다).</p>
    <h3>특수 문자</h3>
    <p >특수 문자는 기존 검색 내에서 제거됩니다. 이것은 구두점 및 관련 문자를 제거하는 것과 거의 같습니다. 제거하는 대신 일반적으로 Elasticsearch에서 이스케이프하므로 검색에서 대신 고려할 가능성이 있습니다.</p>
    <h3>용어 처리</h3>
    <p >기존 검색 쿼리는 '용어 스무싱'을 수행하는 반면 Elasticsearch에서는 형식이 잘못된 용어를 삭제하므로 이 검색을 비어 있는 것으로 간주합니다. <code translate="No">tags:</code>기간: <code translate="No">q=tags: state:ACTIVE</code></p>
    <ul>
      <li><strong>기존의</strong> : <code translate="No">tags:state:ACTIVE</code>— 태그가 있는 비디오 검색<code translate="No">state:ACTIVE</code></li>
      <li><strong>엘라스틱서치</strong> : <code translate="No">state:ACTIVE</code>— 빈 용어 삭제</li>
    </ul>
    <p >댕글링 구두점 및 일반적으로 형식이 잘못된 쿼리를 처리하는 것과 관련된 여러 가지 미묘한 에지 케이스가 있습니다. 우리는 쿼리가 의도한 것으로 생각되는 것을 생성하려고 시도하지만 이러한 경우에는 불행히도 사용자가 의도했을 수 있는 것을 추측하고 있습니다( 정말로 우리는 그들이 검색을 구체화할 수 있도록 오류를 반환했어야 했을 때)</p>
    <h3>재생만 가능</h3>
    <p >현재 재생 가능한 비디오로 검색을 제한하는 두 가지 메커니즘이 있습니다. 쿼리에 플래그가 포함될 수 있거나 쿼리 자체에 재생 가능성의 일부 측면이 필요할 수 있습니다.</p>
    <ul>
      <li>기존: 업데이트된 필드 값을 기반으로 쿼리됩니다.</li>
      <li>Elasticsearch: 계산된 날짜 범위를 기반으로 쿼리됩니다.</li>
    </ul>
    <p >Elasticsearch는 일반적으로 더 정확하고 더 나은 결과를 생성해야 합니다(기존 메커니즘과 관련된 지연이 있으며 플래그 유지 관리 메커니즘이 완전히 신뢰할 수 없음).</p>
    <h3>인덱스 정확도</h3>
    <p >Elasticsearch 인덱스는 기존 인덱스보다 '최신'이며 업데이트를 더 빨리 반영하는 경향이 있습니다. 항상 그런 것은 아니지만 일반적으로 Elasticsearch를 사용한 경험은 결과가 기본 카탈로그 데이터의 상태를 더 정확하게 반영한다는 것입니다. 기존 및 Elasticsearch는 모두 분산 시스템이므로 반환되는 결과가 완전히 일치하지 않습니다. 두 시스템에 대해 반복 쿼리는 잠재적으로 다른 결과를 반환할 수 있습니다(특히 동시에 실행 중인 삭제 작업이 많은 경우).</p>
    <p >기존 검색 결과는 계정이 할당된 샤드의 상태에 따라 변경됩니다. 특정 샤드의 전역 상태는 특정 쿼리의 결과에 영향을 미칠 수 있습니다. Elasticsearch에는 이러한 결함이 없습니다.</p>
  </section>
  <section class="bcls-section">
    <h2 id="Examples">예</h2>
    <h3>실시예 1</h3>
    <p >다음과 같은 제목의 동영상이 두 개 있다고 가정해 보겠습니다.</p>
    <pre>
  <code class="language-html" translate="No">Video#1: has the title “Don’t look into the light”
  Video#2: has the title “Using a lighter to make a campfire”</code></pre>
    <p >사용자는 "빛"이라는 단어가 있어야 하는 모든 비디오를 반환하기를 원합니다. CMS API를 사용하여 쿼리는 다음과 같습니다.</p>
    <pre>
  <code class="language-html" translate="No">q=%2Blight or q=+light</code></pre>
    <p >기존 검색을 사용하면 두 비디오가 모두 다음 순서로 반환됩니다.</p>
    <pre>
  <code class="language-html" translate="No">Video#2 - “Using a lighter to make a campfire”
  Video#1 - “Don’t look into the light”</code></pre>
    <p >여기에는 두 가지 문제가 있습니다.</p>
    <ul>
      <li><strong>관련성</strong> : 주문이 올바르지 않습니다. "라이터를 사용하여 모닥불 만들기"(비디오 #1) 전에 "불을 들여다보지 마십시오"(비디오 #2)가 표시되어야 합니다.</li>
      <li><strong>정확성</strong> : 비디오 제목에 "light"라는 단어가 전혀 표시되지 않기 때문에 "라이터를 사용하여 모닥불 만들기"가 결과 세트에 나타나지 않아야 합니다.</li>
    </ul>
    <p >Elasticsearch를 사용하면 동영상 하나만 반환합니다.</p>
    <pre>
  <code class="language-html" translate="No">Video#1 - “Don’t look into the light”</code></pre>
    <p >이는 다음과 같은 이유로 개선되었습니다.</p>
    <ul>
      <li>관련성: 순서가 정확합니다.</li>
      <li>정확도: 제목에 "빛"이라는 단어가 있는 유일한 비디오이므로 비디오 1만 반환됩니다.</li>
    </ul>
    <h3>예제 2</h3>
    <p >우리의 설명대로<a href="https://apis.support.brightcove.com/cms/searching/cmsplayback-api-videos-search.html#Stemming">형태소 분석을 위한 CMS API 문서</a> , 형태소 분석은 지원되지만 부분 단어 검색은 지원되지 않습니다. 다음과 같은 제목의 동영상이 5개 있다고 가정해 보겠습니다.</p>
    <pre>
  <code class="language-html" translate="No">Video#1 - "Parking Ban Announced"
  Video#2 - "Parking to be Banned"
  Video#3 - "City Banning Parking"
  Video#4 - "Bank Holiday"
  Video#5 - "Bandit Captured"</code></pre>
    <p >사용자는 다음 단어가 포함되어야 하는 모든 동영상을 반환하려고 합니다. <strong>반</strong>이름 필드에서. CMS API를 사용하여 쿼리는 다음과 같습니다.</p>
    <pre>
  <code class="language-html" translate="No">q=%2Bname%3Aban or q=+name:ban</code></pre>
    <p >"Ban"이 세 가지 모두의 어간이므로 "Ban", "Banning" 및 "Banned"가 검색 결과를 생성할 것으로 예상됩니다.</p>
    <p >그러나 현재 검색 시스템에서는 다음과 같은 순서로 5개의 동영상이 모두 반환됩니다.</p>
    <pre>
  <code class="language-html" translate="No">Video#2 - "Parking to be Banned"
  Video#3 - "City Banning Parking"
  Video#1 - "Parking Ban Announced"
  Video#4 - "Bank Holiday"
  Video#5 - "Bandit Captured"</code></pre>
    <p >다시 말하지만 여기에는 두 가지 문제가 있습니다.</p>
    <ul>
      <li>관련성: 주문이 올바르지 않습니다. "주차 금지 발표"는 "금지"라는 단어가 포함되어 있으므로 반환되는 첫 번째 동영상이어야 합니다.</li>
      <li>정확도: "Bank Holiday" 및 "Bandit Captured"는 "Ban"이 "Bank" 또는 "Bandit"이라는 단어의 일부가 아니므로 전혀 반환되지 않아야 합니다.</li>
    </ul>
    <p >Elasticsearch의 결과는 다음과 같습니다.</p>
    <pre>
  <code class="language-html" translate="No">Video#1 - "Parking Ban Announced"
  Video#2 - "Parking to be Banned"
  Video#3 - "City Banning Parking"</code></pre>
    <p >이는 다음과 같은 이유로 개선되었습니다.</p>
    <ul>
      <li>관련성: 순서가 정확합니다.</li>
      <li>정확도: "Ban"("Ban", "Banning" 및 "Banned")이라는 단어의 어간이 있는 비디오만 반환됩니다.</li>
    </ul>
  </section>
</article>
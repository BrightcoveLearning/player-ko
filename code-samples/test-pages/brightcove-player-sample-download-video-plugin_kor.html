<style>
  /* * 본문 스타일은 * 코드펜의 배경색 전용입니다. * 코드에 포함하지 마십시오. */ 신체{ background-color: #111; color: #fff; } /* * 샘플에 필수적인 스타일은 * 아래에 있습니다. */ .video-js { height: 344px; width: 610px; } .download스타일{ order: 9; -webkit-box-ordinal-group: 9; -moz-box-ordinal-group: 9; -webkit-order: 9; -ms-flex-order: 9; padding-top: 7px !important; }




</style>

  <video-js id="myPlayerID"
  data-video-id="5701190170001"
  data-account="1752604059001"
  data-player="S10RYv9QG"
  data-embed="default"
  data-application-id
  class="video-js"
  controls></video-js>

<script src="https://players.brightcove.net/1752604059001/S10RYv9QG_default/index.min.js"></script>

<script>
  videojs.getPlayer('myPlayerID').ready(함수() { // Create variables and new div, anchor and image for download icon var myPlayer = this, videoName, totalRenditions, mp4Ara = [], highestQuality, spacer, newElement = document.createElement("div"), newImage = document.createElement("img"); myPlayer.on("loadstart", function() { //Reinitialize array of MP4 renditions in case used with playlist //This prevents the array having a cumulative list for all videos in playlist mp4Ara = []; // +++ Get video name and the MP4 renditions +++ videoName = myPlayer.mediainfo["name"]; videoName = removeSpaces(videoName); rendtionsAra = myPlayer.mediainfo.sources; console.table(rendtionsAra) totalRenditions = rendtionsAra.length; // +++ Loop over videos and extract only MP4 versions +++ for (var i = 0; i &lt; totalRenditions; i++) { if ( rendtionsAra[i].container === "MP4" &amp;&amp; rendtionsAra[i].hasOwnProperty("src") ) { mp4Ara.push(rendtionsAra[i]); } } // +++ 크기에서 가장 높은 것에서 가장 낮은 것으로 변환을 정렬합니다.+++ mp4Ara.sort(function(a, b) { return b.size - a.size; } ); console.table(mp4Ara) // +++ 가장 높은 렌디션 추출 +++ highQuality = mp4Ara[0].src; // +++ 다운로드 이미지 요소 빌드 +++ newElement.id = "downloadImage"; newElement.className = "vjs-control downloadStyle"; newImage.setAttribute( "src", "https://solutions.brightcove.com/bcls/brightcove-player/download-video/file-download.png"); newImage.style["커서"] = "포인터"; // +++ 이미지 클릭 시 다운로드 함수 호출 +++ newImage.onclick = function() { // The download function forces download by the browsers // NOT opening the video in a new window/tab var x=new XMLHttpRequest(); x.open("GET", highestQuality, true); x.responseType = 'blob'; x.onload=function(e){download(x.response, videoName, "video/mp4"); } x.send(); // }; newElement.appendChild(newImage); // +++ 다운로드 이미지 배치 +++ // 스페이서 요소에 대한 핸들 가져오기 spacer = myPlayer.controlBar.customControlSpacer.el(); // 스페이서의 내용을 오른쪽 정렬로 설정합니다. spacer.setAttribute("style", "justify-content: flex-end;"); // 스페이서에 새 요소를 배치합니다. spacer.appendChild(newElement); }); }); /* * 문자열에서 공백 제거 * @param {String}처리할 문자열 * @return {String}트리밍된 문자열 */ 함수 removeSpaces(str) { // remove spaces and periods str = str.replace(/\s/g, ''); str = str.replaceAll('.', ''); return str; } //download.js v4.2, dandavis 제공; 2008-2016. [CCBY2] 테스트/사용법은 http://danml.com/download.html 참조 // v1은 FF+Chrome 호환 방식으로 문자열을 로컬 이름 없는 파일로 다운로드하고, 숨겨진 프레임과 선택적 MIME을 사용하도록 업그레이드했습니다. // v2는 a[download], msSaveBlob, IE(10+) 지원 및 dataURLs보다 더 크고 빠른 저장을 위한 window.URL 지원을 통해 명명된 파일을 추가했습니다. 강제 다운로드 MIME 및 base64 지원으로 개선되었습니다. 3.1 향상된 사파리 처리.//v4는 AMD/UMD, CommonJS 및 일반 브라우저 지원을 추가합니다//v4.1은 솔로 URL 인수 (동일한 도메인/COR에만 해당) 를 통해 URL 다운로드 기능을 추가합니다.//v4.2는 의미 변수 이름, 긴 (2MB 이상) 데이터 aURL 지원 및 기본 임시 앵커로 숨김//https://github.com/rndme/download (함수 (루트, 팩토리) { if (typeof define === "function" &amp;&amp; define.amd) { // AMD. Register as an anonymous module. define([], factory); }그렇지 않으면 (내보내기 유형 === “객체”) { // Node. Does not work with strict CommonJS, but // only CommonJS-like environments that support module.exports, // like Node. module.exports = factory(); }다른{ // Browser globals (root is window) root.download = factory(); } }) (함수 () { return function download(data, strFileName, strMimeType) { var self = window, // this script is only for browsers anyway... defaultMime = "application/octet-stream", // this default mime also triggers iframe downloads mimeType = strMimeType || defaultMime, payload = data, url = !strFileName &amp;&amp; !strMimeType &amp;&amp; payload, anchor = document.createElement("a"), toString = function(a) { return String(a); } , MyBlob = 셀프.BLOB || 셀프.MozBlob || 셀프.WebkitBlob || toString, 파일 이름 = strfilename|| " 다운로드”, 얼룩, 리더; MyBlob = MyBlob. 전화?마이블롭.바인드 (자체): Blob; if (문자열 (이) === “참”) { //reverse arguments, allowing download.bind(true, "text/xml", "export.xml") to act as a callback payload = [payload, mimeType]; mimeType = payload[0]; payload = payload[1]; }경우 (URL &amp;&amp; url.length  &lt;  2048) { // if no filename and no mime, assume a url was passed as the only argument fileName = url .split("/") .pop() .split("?")[0]; anchor.href = url; // assign href prop to temp anchor if (anchor.href.indexOf(url) !== -1) { // if the browser determines that it's a potentially valid url path: var ajax = new XMLHttpRequest(); ajax.open("GET", url, true); ajax.responseType = "blob"; ajax.onload = function(e) { download(e.target.response, fileName, defaultMime); } ; setTimeout (함수 () { ajax.send(); } , 0);//반환을 사용하여 사용자 정의 아약스 헤더를 설정할 수 있습니다: 아약스 반환;}//유효한 URL이면 끝나나요?}//끝 if url?//(/^data\: [\ w+\ -] +\/[\ w+\ -] + [,;] /.test (페이로드)) { if (payload.length &gt; 1024 * 1024 * 1.999 &amp;&amp; myBlob !== toString) { payload = dataUrlToBlob(payload); mimeType = payload.type || defaultMime; }다른 경우{ return navigator.msSaveBlob // IE10 can't do a[download], only Blobs: ? navigator.msSaveBlob(dataUrlToBlob(payload), fileName) : saver(payload); // everyone else can save dataURLs un-processed } } //데이터 URL을 즉시 다운로드하십시오.blob = MyBlob의 페이로드 인스턴스?페이로드: 새로운 MyBlob ([페이로드], { type: mimeType } ); 함수 데이터 AurltoBlob (strURL { var parts = strUrl.split(/[:;,]/), type = parts[1], decoder = parts[2] == "base64" ? atob : decodeURIComponent, binData = decoder(parts.pop()), mx = binData.length, i = 0, uiArr = new Uint8Array(mx); for (i; i &lt; mx; ++i) uiArr[i] = binData.charCodeAt(i); return new myBlob([uiArr], { type: type } ));} 함수 보호기 (URL, 윈모드) { if ("download" in anchor) { //html5 A[download] anchor.href = url; anchor.setAttribute("download", fileName); anchor.className = "download-js-link"; anchor.innerHTML = "downloading..."; anchor.style.display = "none"; document.body.appendChild(anchor); setTimeout(function() { anchor.click(); document.body.removeChild(anchor); if (winMode === true) { setTimeout(function() { self.URL.revokeObjectURL(anchor.href); } , 250);}}, 66); 참을 반환;}//우리가 할 수있는 최선의 방법으로 비 [다운로드] 사파리를 처리합니다: 만약 (/(버전)\/(\ d+)\.(\ d+) (?:\.(\ d+))?*사파리\ //.test (네비게이터.사용자 에이전트)) { url = url.replace(/^data:([\w\/\-\+]+)/, defaultMime); if (!window.open(url)) { // popup blocked, offer direct download: if ( confirm( "Displaying New Document\n\nUse Save As... to download, then click back to return to this page." ) ) { location.href = url; } } 참을 반환합니다;} //iframe 데이터 경로 다운로드 (이전 ch+ff): var f = 문서.생성 요소 (“iframe”); 문서.본문.추가 자식 (f); 만약 (!윈모드) { // force a mime that will download: url = "data:" + url.replace(/^data:([\w\/\-\+]+)/, defaultMime); } f.src = URL; 설정 시간 초과 (함수 () { document.body.removeChild(f); } , 333);} //최종 보호기 (탐색기.mssaveBlob) { // IE10+ : (has Blob, but not a[download] or URL) return navigator.msSaveBlob(blob, fileName); }경우 (셀프.URL) { // simple fast and modern way using Blob and URL: saver(self.URL.createObjectURL(blob), true); }그렇지 않으면{ // handle non-Blob()+non-URL browsers: if (typeof blob === "string" || blob.constructor === toString) { try { return saver("data:" + mimeType + ";base64," + self.btoa(blob)); }캐치 (y) { return saver("data:" + mimeType + "," + encodeURIComponent(blob)); } }//BlobURL 지원 안 함: 리더 = 새 파일 리더 (); 리더.onload = 함수 (e) { saver(this.result); } ; 리더.readasDataURL (blob);} true를 반환합니다;}; /* 최종 다운로드 () */});




</script>
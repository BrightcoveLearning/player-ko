
---
title: 라이브 스트림 구성
parent: General Information
description: In this topic, you will learn how live stream configuration affects the bandwidth available for media playback. The goal of the document is to make you aware how incorrect configuration can impact the user experience for a live stream, rendering it nearly unplayable. 
---

<article class="bcls-article">
  <h1>라이브 스트림 구성</h1>
  <summary>{{ page.description }}</summary>
        <section class="bcls-section">
    <aside class="bcls-aside bcls-aside--information">라이브 스트림 구성은 CDN 및/또는 인코더와 함께 수행됩니다. Brightcove Player는 전송된 내용만 재생할 수 있으며 잘못된 라이브 스트림 구성을 보정할 수 있는 Brightcove Player 조정이 없습니다.</aside>
  </section>
  <section id="Live_stream_configuration_terminology" class="bcls-section">
    <h2>라이브 스트림 구성 용어</h2>
    <p>이 문서의 하단에있는 계산기는 라이브 스트림 구성을 기반으로 한 대략적인 오버 헤드 대역폭 추정치를 제공합니다. 계산기에 필요한 라이브 스트리밍 및 정보에 대한 기본 지식이 있는지 확인하기 위해 몇 가지 용어가 여기에 정의되어 있습니다.</p>
    <table class="bcls-table">
      <thead class="bcls-table__head">
        <tr>
          <th style="width: 25%">학기</th>
          <th>정의</th>
        </tr>
      </thead>
      <tbody class="bcls-table__body">
        <tr>
          <td>HTTP 라이브 스트리밍(HLS)</td>
          <td>오디오 및 비디오를 미디어 세그먼트 파일이라고하는 일련의 작은 파일로 보냅니다.</td>
        </tr>
        <tr>
          <td>목표 기간</td>
          <td>미디어 세그먼트의 최대 지속 시간을 지정하는 미디어 재생 목록 내의 매개 변수입니다.</td>
        </tr>
        <tr>
          <td>미디어 재생 목록 파일</td>
          <td>미디어 세그먼트 파일의 URL 순서 목록을 제공하는 색인 파일입니다. 매니페스트 파일이라고도합니다.</td>
        </tr>
        <tr>
          <td>마스터 재생 목록 URL</td>
          <td>계산에 사용할 재생 목록 파일의 위치입니다.</td>
        </tr>
        <tr>
          <td>상대 URL</td>
          <td>재생 목록 파일의 경로는 재생 목록과 관련된 URL을 사용할 수 있으므로 파일에서 상당한 공간을 절약 할 수 있습니다 (일반적으로 50 % 이상).</td>
        </tr>
        <tr>
          <td>라이브 창</td>
          <td>시청자가 동영상을보기 위해 실시간 스트림에서 시간을 거꾸로 이동할 수있는 시간입니다. 내부적으로 이것은 재생 목록 파일에 보관해야하는 세그먼트 수로 변환됩니다. 따라서 라이브 창이 길수록 재생 목록 파일이 커집니다.</td>
        </tr>
        <tr>
          <td>세그먼트 기간</td>
          <td>각 세그먼트의 기간입니다. 세그먼트 크기가 감소하면 매니페스트 크기가 증가합니다. 더 큰 세그먼트 크기의 주요 단점은 대역폭 변경에 대한 적응성이 떨어지고 라이브 지연 시간이 길다는 것입니다.</td>
        </tr>
      </tbody>
    </table>
  </section>
  <section id="How_HLS_Live_works" class="bcls-section">
    <h2>HLS Live 작동 방식</h2>
    <p>라이브 스트림에서 플레이어는 설정된 간격으로 미디어 재생 목록을 반복적으로 다운로드합니다. 그 간격은 다음과 같은 시간입니다. <strong>목표 기간</strong>미디어 재생 목록의.</p>
    <p>예를 들어 대상 기간이 10 초인 100KB 매니페스트가있는 경우 다음 계산은 미디어 재생 목록을 다운로드하는 데 사용되는 대역폭을 결정합니다.</p>
    <ul>
      <li>100KB / 10 초 * 바이트 당 8 비트 = <strong> 80kbps</strong>비디오 재생을 계속하기 위해 미디어 재생 목록을 다운로드하는 대역폭</li>
    </ul>
    <p>이 대역폭은 실제 미디어에 사용할 수있는 대역폭을 빼앗는 오버 헤드로 간주됩니다.</p>
  </section>
  <section id="Calculator" class="bcls-section">
    <h2>계산자</h2>
    <p>아래 계산기를 사용하여 특정 라이브 스트림 구성 값을 조작하고 해당 변경 사항의 결과를 볼 수 있습니다. <strong>세그먼트 수</strong> , <strong>예상 매니페스트 크기</strong>과<strong>예상 대역폭 오버 헤드</strong> . 대상 고객이 사용할 수있는 대역폭을 귀하 만이 알고 있기 때문에 이러한 결과에 대한 정확한 모범 사례 번호를 제공하기가 어렵습니다. 그러나 300kbps의 최소 변환을 제공하고 가져 오는 데 1mbps가 걸리는 너무 큰 매니페스트를 갖는 것은 의미가 없음을 인식하십시오. 너무 많은 오버 헤드 대역폭의 결과는 비디오가 재생되었지만 중단되거나 매니페스트 업데이트를 따라갈 수없는 경우 플레이어가 라이브 창을 벗어날 수 있습니다. 기본적으로 사용 가능한 모든 대역폭은 매니페스트 업데이트를 다운로드하는 데 사용되며 실제 비디오 세그먼트는 다운로드 할 수 없습니다.</p>
    <table class="bcls-table">
      <tbody class="bcls-table__body">
        <tr>
          <td>마스터 재생 목록 URI</td>
          <td><input type="text" id="manifestUri" value="https://examplethingy-i.akamaihd.net/hls/live/999999/exampleustestthingy/master.m3u8" size="100" /></td>
        </tr>
        <tr>
          <td>상대 URI 사용</td>
          <td><input type="checkbox" id="relativeUri" /></td>
        </tr>
        <tr>
          <td>라이브 창 크기</td>
          <td><input style="display:inline-block;margin-right:10px;max-width:10%" type="number" id="liveWindowSize" value="5" />
            <select style="display:inline-block;max-width:20%" name="scale" id="liveWindowScale">
              <option value="1">초</option>
              <option value="3600">시간</option>
              <option value="86400" selected="selected">일</option>
              <option value="31557600">연령</option>
            </select></td>
        </tr>
        <tr>
          <td>평균 세그먼트 기간<br />
            (초 단위)</td>
          <td><input style="max-width: 10%" type="number" id="segmentDuration" value="9" /></td>
        </tr>
      </tbody>
    </table>
    <div>세그먼트 수 :</div>
    <div>예상 매니페스트 크기 :</div>
    <div>예상 대역폭 오버 헤드 :</div>
  </section>
  <script>
          let bandwidthScaleTable = [ 'bps', 'kbps', 'mbps', 'gbps', 'tbps', 'pbps', 'ebps'  ]; let sizeScaleTable = [ 'B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB'  ]; 절대UriOverhead = 54; relativeUriOverhead = 55; hlsHeaderOverhead = 120; // 미디어 재생 목록의 시작 부분에 있는 EXT-X-* 태그 let hlsSegmentOverhead = 10; // EXT-INF 태그 함수 foo() { let manifestUri = document.querySelector('#manifestUri').value; let rootManifest = manifestUri.split('/').slice(0, -1).join('/'); let relativeUri = document.querySelector('#relativeUri').checked; let liveWindowSize = parseFloat(document.querySelector('#liveWindowSize').value); let liveWindowScale = parseFloat(document.querySelector('#liveWindowScale').value); let segmentDuration = parseFloat(document.querySelector('#segmentDuration').value); let liveWindowDuration = liveWindowSize * liveWindowScale; let baseUriLength = relativeUri ? relativeUriOverhead : absoluteUriOverhead + rootManifest.length; let segmentCount = Math.ceil(liveWindowDuration / segmentDuration); let estimate = hlsHeaderOverhead + (baseUriLength + hlsSegmentOverhead) * segmentCount; let bandwidthEstimate = estimate / segmentDuration * 8; //in bits per second let estimateScale = 0; while (estimate &gt; 1024) { estimate /= 1024; estimateScale++; } bandwidthScale = 0으로 둡니다. 동안 (bandwidthEstimate &gt; 1024) { bandwidthEstimate /= 1024; bandwidthScale++; } document.querySelector('#manifestSize').innerHTML = 추정.toFixed(2) + sizeScaleTable[estimateScale]; document.querySelector('#manifestBandwidth').innerHTML = bandwidthEstimate.toFixed(2) + bandwidthScaleTable[bandwidthScale]; document.querySelector('#segmentCount').innerHTML = segmentCount; } let 요소 = document.querySelectorAll('입력, 선택'); for (let i = 0; i &lt; elements.length; i++) elements[i].addEventListener('change', foo); 푸();
        </script></article>
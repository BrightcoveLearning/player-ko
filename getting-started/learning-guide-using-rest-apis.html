
---
title: '학습 가이드: REST API 사용'
description: '이 주제에서는 먼저 REST API 사용에 대한 높은 수준의 개요를 얻습니다. 그런 다음 문서 후반부에서 예제 코드에 대해 자세히 설명합니다. 첫 번째 예에서는 다음을 사용합니다. <span translate="No">애널리틱스 API</span>현재 플레이어에 있는 비디오의 조회수를 검색하고 Brightcove 플레이어 컨트롤 막대에 표시합니다. 두 번째이자 약간 더 복잡한 예제는 다음을 사용합니다. <span translate="No">애널리틱스 API</span> Brightcove Player 카탈로그와 함께 계정에서 가장 인기 있는 비디오를 검색하고 재생 목록에 표시합니다. 이 문서의 코드 토론은 올바른 REST API에서 원하는 데이터를 검색하는 데 중점을 둡니다.'
parent: Getting Started 
---


<!-- 
  This content appears on:
  
  https://apis.support.brightcove.com/getting-started/learning-guide-using-rest-apis.html

  https://player.support.brightcove.com/getting-started/learning-guide-using-rest-apis.html

  If you update in one place, you MUST update it in all!
 -->

 <h1>{{ page.title }}</h1>
 <article class="bcls-article">
  <summary>{{ page.description }}</summary>
  <section class="bcls-section">
    <h2 id="High_level_view">높은 수준의 보기</h2>
    <p>REST API를 사용하려면 몇 가지 부분이 준비되어 있어야 합니다. 간단히 말해서 다음과 같습니다.</p>
    <ul>
      <li><strong>클라이언트 코드</strong> : 클라이언트 코드는 특정 데이터를 요청한 다음 애플리케이션 요구 사항에 따라 이를 표시합니다. 클라이언트 코드는 가장 자주 작성해야 하는 코드이므로 이 문서에서 어느 정도 길게 설명합니다.</li>
      <li><strong>프록시 서버</strong> : 보안상의 이유로 REST API는 클라이언트 자격 증명과 같은 기밀 정보를 클라이언트에서 보내도록 권장하므로 클라이언트에서 직접 데이터 요청을 수락하지 않습니다. 이는 프록시가 클라이언트와 REST API 사이의 중개자 역할을 한다는 것을 의미합니다. 예제에 사용된 프록시는 PHP로 작성되었으며 이 문서의 뒷부분에서 설명합니다. 프록시는 사용자가 제어하는 서버에 설정해야 하며 선택한 언어로 작성할 수 있습니다. 프록시의 제안된 구성을 사용하면 한 번 작성하고 모든 API에서 사용할 수 있습니다.</li>
      <li><strong>REST API</strong> : Brightcove는 Brightcove 플랫폼과 사용자 지정, 확장 및 통합할 수 있는 포괄적인 API 세트를 제공합니다. <a href="https://apis.support.brightcove.com/getting-started/getting-started-brightcove-apis.html">개요를 참조하십시오. 비디오 클라우드 API</a>자세한 내용은 문서를 참조하십시오.</li>
    </ul>
    <p>다음 다이어그램은 Brightcove의 REST API 중 하나에서 데이터를 검색하는 프로세스의 세 가지 핵심 엔터티 간의 상호 작용을 보여줍니다.</p>
    <figure class="bcls-figure"><img class="bcls-image" alt="Basic Pieces Overview" src="//learning-services-media.brightcove.com/doc-assets/player-development/architecture/proxy-API-call/client-proxy-api.png" /></figure>
  </section>
  <section class="bcls-section">
    <h2 id="Client_functionality_overview">클라이언트 기능 개요</h2>
    <p>클라이언트 측 코드는 데이터를 요청하는 API에 따라 크게 변경됩니다. 위에서 언급했듯이 프록시는 한 번 쓰기이며 코드를 수정하지 않으며 API는 Brightcove에서 유지 관리합니다. 이것이 문서에서 API 중 하나에서 원하는 데이터를 검색하기 위해 클라이언트 코드를 변경하는 방법을 배우는 데 중점을 두는 이유입니다.</p>
    <p>아래 다이어그램은 클라이언트 코드의 주요 부분에 중점을 두고 있습니다.</p>
    <ul>
      <li>만들어주는 기능<code translate="No">HTTPRequest</code>프록시에. 모호성을 피하기 위해 함수의 이름은<code translate="No">makeRequest()</code> . 아래 그림의 오른쪽에 있는 그림입니다.</li>
      <li>요청에 필요한 정보를 수집하는 코드입니다. 다이어그램의 왼쪽 상단에 있는 그림입니다. 이 코드는 일반적으로 매우 간단하며 초보 프로그래머에게도 잘 알려진 개념을 사용합니다.</li>
      <li>앞서 언급한 호출을 실행<code translate="No">makeRequest()</code>기능. 다이어그램의 왼쪽 아래에 그림이 있습니다. 호출은 다음으로 함수를 전달합니다. <code translate="No">makeRequest()</code>매개변수로. 그런 다음<code translate="No">makeRequest()</code>그 함수가 호출됩니다. 이것은 익명으로 정의된<strong>콜백</strong>기능.</li>
    </ul>
    <p>레이블이 지정된 다이어그램의 두 섹션이 표시됩니다. <strong>비동기 활동</strong> . 다이어그램에서 두 개의 다른 위치에 표시되지만 실제로는 동일한 비동기 활동이며 다음과 같은 알 수 없는 시간을 나타냅니다.</p>
    <ul>
      <li>프록시에 요청을 보낼 클라이언트입니다.</li>
      <li>API에서 데이터를 요청하는 프록시입니다.</li>
      <li>결과 집합을 빌드하고 프록시에 반환하는 API입니다.</li>
      <li>클라이언트에 데이터를 반환하는 프록시입니다.</li>
    </ul>
    <p>다음을 호출하는 상자의 논리 흐름 화살표에 유의하십시오. <code translate="No">makeRequest()</code> (왼쪽 아래 상자)는 코드가 두 개의 다른 시간에 실행되었음을 나타내는 것 같으며, 정확히 그렇습니다. 함수에 대한 호출이 이루어지지만 콜백 함수는<code translate="No">makeRequest()</code>작업을 완료하고 콜백 함수가 실행되어 요청된 데이터를 함수 호출 코드로 반환합니다.</p>
    <figure class="bcls-figure"><img class="bcls-image" alt="Client functionality overview" src="//learning-services-media.brightcove.com/doc-assets/player-development/architecture/proxy-API-call/proxy-API-call.png" /></figure>
  </section>
  <section class="bcls-section">
    <h2 id="Example_code_walkthrough">예제 코드 연습</h2>
    <p>코드를 한 조각으로 보는 대신 섹션에서 제시하고 논의할 것입니다. 일부 섹션은 위의 다이어그램과 관련이 있습니다.</p>
    <h3>표준 플레이어 코드</h3>
    <p>이 코드 섹션에는 기본 Brightcove Player 인페이지 내장 코드가 포함되어 있습니다.</p>
    <ul>
      <li>11-21행: 추가된 표준 Brightcove Player 코드&nbsp;<code translate="No">id</code>속성이 추가되었습니다.</li>
    </ul>
    <pre class="line-numbers">
	<code class="language-html" translate="No">&lt;!doctype html&gt;
	&lt;html&gt;
	
	&lt;head&gt;
		&lt;meta charset="UTF-8"&gt;
		&lt;title&gt;Untitled Document&lt;/title&gt;
	&lt;/head&gt;
	
	&lt;body&gt;
	
	&lt;video-js id="myPlayerID"
		data-video-id="3851380732001"
		data-account="1752604059001"
		data-player="HkAzSmB0l"
		data-embed="default"
		data-application-id
		class="video-js"
		controls
		width="640"
		height="360"&gt;&lt;/video-js&gt;
	&lt;script src="https://players.brightcove.net/1752604059001/HkAzSmB0l_default/index.min.js"&gt;&lt;/script&gt;</code></pre>
    <h3>전화 걸 준비 중</h3>
    <p>이 코드 섹션은 변수를 초기화하고<code translate="No">makeRequest()</code> . 일반적으로 읽기 요청의 경우 다음 정보를 제공해야 합니다.</p>
    <ol>
      <li>예를 들어 사용할 프록시에 대한 URL(물론 이것은 사용자가 제어하는 프록시여야 함):
        <pre class="line-numbers">
	<code class="language-html" translate="No">https://solutions.brightcove.com/bcls/bcls-proxy/doc-samples-proxy-v2.php</code></pre>
      </li>
      <li>실제 요청에 필요한 URL로 일반적으로 동적으로 구성됩니다.
        <pre class="line-numbers">
	<code class="language-html" translate="No">https://analytics.api.brightcove.com/v1/alltime/accounts/1752604059001/videos/4825279519001</code></pre>
      </li>
      <li>예를 들어 HTTP 메소드<code translate="No">GET</code> .</li>
    </ol>
    <p>예는 다음과 같습니다.</p>
    <ul>
      <li>1호선: 플레이어가 상호 작용할 준비가 될 때까지 기다리는 표준 코드입니다.</li>
      <li>2-4행: 나중에 코드에서 필요한 변수에 대한 값을 생성/설정합니다.</li>
      <li>7-12번 라인: 기다려<code translate="No">loadstart</code>이벤트 그래서<code translate="No">mediainfo</code>개체가 채워집니다. 에 필요한 값을 유지하기 위해 변수를 할당합니다. <span translate="No">애널리틱스 API</span>끝점.</li>
      <li>13번 호선: 호출에 대한 HTTP 메서드를 설정합니다.</li>
    </ul>
    <pre class="line-numbers">
	<code class="language-javascript" translate="No">videojs.getPlayer('myPlayerID').ready(function() {
	&nbsp; var myPlayer = this,
		accountId = myPlayer.bcinfo.accountId,
		options = {};
	
		// +++ Wait for loadstart event so can use mediainfo object +++
		myPlayer.on('loadstart', function() {
			var videoId = myPlayer.mediainfo.id,
			baseURL = 'https://analytics.api.brightcove.com/v1/alltime/accounts/',
			endPoint = accountId + '/videos/' + videoId;
			options.proxyURL = "https://solutions.brightcove.com/bcls/bcls-proxy/doc-samples-proxy-v2.php";
			options.url = baseURL + endPoint;
			options.requestType = "GET";</code></pre>
    <aside class="bcls-aside bcls-aside--information">참고: 라인 9,10, 12는 하나의 긴 라인에 쉽게 배치될 수 있습니다. 코드는 보기로 스크롤해야 하는 긴 줄을 피하고 코드 재사용성을 돕기 위해 표시된 대로 작성되었습니다.</aside>
    <h3>부르다<code translate="No">makeRequest()</code></h3>
    <p>이 코드 섹션은<code translate="No">makeRequest()</code>기능. 두 개의 매개변수가 전달됩니다. 첫 번째는 끝점에 대한 정보를 보유하는 옵션 객체이고 두 번째는 콜백 함수입니다. 이것은 비동기식 호출이므로 REST API가 데이터를 반환할 때까지 익명으로 정의된 콜백 함수가 호출되지 않습니다. <code translate="No">makeRequest()</code>기능.</p>
    <ul>
      <li>1호선: 를 불러<code translate="No">makeRequest()</code>함수, 호출에 필요한 값 전달<code translate="No">options</code>물체. 이 경우 객체에는 다음이 포함됩니다.
        <figure class="bcls-figure"><img class="bcls-image" alt="options object" src="//learning-services-media.brightcove.com/doc-assets/player-development/architecture/proxy-API-call/options-object-console.png" /></figure>
      </li>
      <li>3-13행: 콜백 함수는 익명 함수로 정의됩니다(노란색으로 강조 표시됨). 이 함수는 매개변수이며 여기에서 호출되지 않고 나중에 코드에서 호출된다는 점을 기억하십시오.</li>
      <li>6, 8, 10행: <code translate="No">console.log()</code>다음을 표시하는 문:
        <ul>
          <li>API 호출에서 반환되는 원시 JSON 문자열입니다.</li>
          <li>에 의해 생성된 JSON 객체<code translate="No">JSON.parse()</code>문자열에서 객체로 변환하는 메소드.</li>
          <li>단순 뷰를 사용하여 객체에서 추출한 실제 조회수<code translate="No">object.property</code>표기법.</li>
        </ul>
      </li>
      <li>12번 호선: 컨트롤 바의 뷰 수를 표시하는 함수를 호출합니다.</li>
    </ul>
    <p>콘솔의 다음 스크린샷은 실제 표시된 데이터를 보여줍니다. <code translate="No">console.log</code>진술:</p>
    <figure class="bcls-figure"><img class="bcls-image" alt="Processing of data in callback function" src="//learning-services-media.brightcove.com/doc-assets/player-development/architecture/proxy-API-call/console-data-process-callback-function.png" /></figure>
    <pre class="line-numbers">
	<code class="language-javascript" translate="No">// +++ Make the request to the <span translate="No">Analytics API</span> +++
	// Extract views from data returned by Analytics API
	makeRequest(options, <span class="bcls-highlight">function(viewsRaw) {
	var viewsCount;
	// Remove console.log command for production code
	console.log('viewsRaw', viewsRaw);
	viewsObject = JSON.parse(viewsRaw);
	console.log('viewsObject', viewsObject);
	viewsCount = viewsObject.alltime_video_views;
	console.log('views', viewsCount);
	// Call function to place data in controlbar
	placeCountInControlbar(viewsCount);
	}</span>);</code></pre>
    <h3>실제<code translate="No">makeRequest()</code>기능</h3>
    <p>문서의 이 섹션에서는 실제로 정의하는 코드를 검사합니다. <code translate="No">makeRequest()</code>기능. 함수를 정의하는 코드는 수정할 필요가 없지만 그대로 반복적으로 사용되는 방식으로 작성됩니다. 이것이 사실이 아닌 극단적인 경우를 찾을 수 있지만 대부분의 경우 이 코드를 수정할 필요가 없습니다.</p>
    <aside class="bcls-aside bcls-aside--tip">이해의 핵심 개념<code translate="No">makeRequest()</code>기능이 어떻게<code translate="No">XMLHttpRequest</code>개체가 동작합니다. NS <code translate="No">XMLHttpRequest.onreadystatechange</code>때마다 호출되는 이벤트 핸들러입니다. <code translate="No">readyState</code>속성 변경. 할당된 값은 사용자가 작성하는 이벤트 핸들러 기능 코드입니다. 다음 표는 값을 보여줍니다. <code translate="No">readyState</code>속성이 가질 수 있는 것과 각 값이 의미하는 것:
      <table class="bcls-table">
        <thead class="bcls-table__head">
          <tr>
            <td class="header">가치</td>
            <td class="header">상태</td>
            <td class="header">설명</td>
          </tr>
        </thead>
        <tbody class="bcls-table__body">
          <tr>
            <td><code translate="No">0</code></td>
            <td><code translate="No">UNSENT</code></td>
            <td>클라이언트가 생성되었습니다. <code translate="No">open()</code>아직 호출되지 않았습니다.</td>
          </tr>
          <tr>
            <td><code translate="No">1</code></td>
            <td><code translate="No">OPENED</code></td>
            <td><code translate="No">open()</code>호출되었습니다.</td>
          </tr>
          <tr>
            <td><code translate="No">2</code></td>
            <td><code translate="No">HEADERS_RECEIVED</code></td>
            <td><code translate="No">send()</code>호출되었으며 헤더 및 상태를 사용할 수 있습니다.</td>
          </tr>
          <tr>
            <td><code translate="No">3</code></td>
            <td><code translate="No">LOADING</code></td>
            <td>다운로드 중; <code translate="No">responseText</code>부분 데이터를 보유합니다.</td>
          </tr>
          <tr>
            <td><code translate="No">4</code></td>
            <td><code translate="No">DONE</code></td>
            <td>작업이 완료되었습니다.</td>
          </tr>
        </tbody>
      </table>
      <p>코드에서 이벤트 핸들러가 어떻게 활용되는지 정확히 알 수 있습니다.</p>
    </aside>
    <p>코드에 대한 한 줄 한 줄 토론은 다음과 같습니다.</p>
    <ul>
      <li>1-6행: 함수 정의 및 변수 생성. 핵심은 새로운<code translate="No">XMLHttpRequest</code>객체가 생성됩니다.</li>
      <li>8, 26행: 에 대한 이벤트 핸들러 함수를 정의합니다. <code translate="No">readyState</code>변경.</li>
      <li>9, 23, 25행: 사용<code translate="No">try-catch</code>요청이 높은 수준에서 실패한 경우.</li>
      <li>10, 11행: 사용하다<code translate="No">if</code>요청이 완료되었는지 확인하는 명령문( <code translate="No">readyState</code> 4) 성공적으로 완료되면 상태는 200 범위에 있습니다. 다음은 콘솔 로깅을 보여줍니다. <code translate="No">readyState</code>그리고<code translate="No">status</code>이벤트 핸들러 정의의 값:
        <figure class="bcls-figure"><img class="bcls-image" alt="Logging readyState and status" src="//learning-services-media.brightcove.com/doc-assets/player-development/architecture/proxy-API-call/console-readystate-and-status.png" /></figure>
      </li>
      <li>18호선: 콜백 함수가 실행됩니다. 이렇게 하면 API에서 반환된 데이터가 에 자세히 설명된 대로 콜백 함수로 다시 전달됩니다. <strong> makeRequest() 호출</strong>위 섹션.</li>
      <li>33행: 이벤트 핸들러 설정<code translate="No">XMLHttpRequest.onreadystatechange</code>이벤트.</li>
      <li>35번 라인: 프록시에 대한 요청을 초기화합니다.</li>
      <li>38행: 비동기 요청을 보냅니다.</li>
    </ul>
    <pre class="line-numbers">
	<code class="language-javascript" translate="No">function makeRequest(options, callback) {
	var httpRequest = new XMLHttpRequest(),
	response,
	requestParams,
	dataString,
	proxyURL = options.proxyURL,
	// response handler
	getResponse = function() {
	try {
		if (httpRequest.readyState === 4) {
			if (httpRequest.status &gt;= 200 &amp;&amp; httpRequest.status &lt; 300) {
				response = httpRequest.responseText;
				// some API requests return '{null}' for empty responses - breaks JSON.parse
				if (response === '{null}') {
					response = null;
				}
				// return the response
				callback(response);
			} else {
				alert('There was a problem with the request. Request returned ' + httpRequest.status);
			}
		}
	} catch (e) {
		alert('Caught Exception: ' + e);
	}
	};
	/**
	* set up request data
	* the proxy used here takes the following request body:
	* JSON.stringify(options)
	*/
	// set response handler
	httpRequest.onreadystatechange = getResponse;
	// open the request
	httpRequest.open('POST', proxyURL);
	// set headers if there is a set header line, remove it
	// open and send request
	httpRequest.send(JSON.stringify(options));
	}</code></pre>
    <h3>반환된 데이터 표시</h3>
    <p>이 코드는 반환된 데이터를 컨트롤 막대에 배치하는 방법을 보여줍니다. 이 함수는 다음과 같이 콜백 함수의 끝에서 호출됩니다. <strong> makeRequest() 호출</strong>위 섹션.</p>
    <ul>
      <li>5, 16행: 기능을 정의합니다.</li>
      <li>6호선: 에 대한 변수를 생성합니다. <code translate="No">spacer</code>컨트롤 바의 요소.</li>
      <li>7번 라인: 동적으로 생성<code translate="No">div</code>요소.</li>
      <li>9번 라인: 새로 생성된 뷰에 레이블과 값을 배치합니다. <code translate="No">div</code>요소.</li>
      <li>11번 행: 자바스크립트를 사용<code translate="No">document.getElementsByClassName()</code>컨트롤바를 얻는 방법<code translate="No">spacer</code>요소.</li>
      <li>13번 호선: 스타일<code translate="No">spacer</code>전체 조회수를 오른쪽 정렬하고 상단에서 10px 아래로 표시하려면<code translate="No">spacer</code> .</li>
      <li>15호선: 새로 생성되고 채워지고 스타일이 지정된 요소를<code translate="No">spacer</code> .</li>
    </ul>
    <pre class="line-numbers">
	<code class="language-javascript" translate="No">/**
	* Dynamically build a div that is then
	* placed in the controlbar's spacer element
	*/
	function placeCountInControlbar(viewsCount) {
	var spacer,
	newElement = document.createElement('div');
	//Place data in div
	newElement.innerHTML = "Total Views: " + viewsCount;
	//Get the spacer in the controlbar
	spacer = document.getElementsByClassName('vjs-spacer')[0];
	//Right justify content in the spacer and add top margin
	spacer.setAttribute('style', 'justify-content: flex-end; margin-top: 10px');
	//Add the dynamically built div to the spacer in the controlbar
	spacer.appendChild(newElement);
	}</code></pre>
    <h3>전체 코드 목록</h3>
    <p>작동하는 완전한 코드는 다음 GitHub 리포지토리에 있습니다. <a href="https://github.com/BrightcoveLearning/learning-guide-using-rest-apis/blob/master/display-views-in-controlbar.html"> display-views-in-controlbar.html</a> .</p>
  </section>
  <section class="bcls-section">
    <h2 id="Simple_debugging">간단한 디버깅</h2>
    <p>보시다시피 REST API를 사용할 때 관련된 많은 부분이 있습니다. 앱이 제대로 작동하지 않을 때 문제가 발생할 수 있습니다. 어디서 디버깅을 시작합니까?</p>
    <p>이 섹션에서는 몇 가지 간단한 제안을 하고 디버깅 모험을 시작하기에 좋은 곳입니다. 다음 두 섹션에서는 필요한 가장 기본적인 정보, 호출을 위해 전달되는 정보 및 반환되는 정보를 볼 수 있는 방법을 제공합니다.</p>
    <h3>통화 옵션 확인</h3>
    <p>이 문서에서 논의된 클라이언트 측 코드는 기본적으로 프록시와 함께 사용할 올바른 옵션을 제공하고 실제 API를 제공하는 것에 관한 것입니다. 따라서 옵션이 올바른지 아는 것은 코드가 올바르게 작동하는 데 필수적입니다. 이를 수행하는 간단한 방법은 콘솔에 기록하는 것입니다. <code translate="No">options</code>객체에 전달되기 직전에<code translate="No">makeRequest</code>사용되는 기능:</p>
    <figure class="bcls-figure"><img class="bcls-image" alt="debugging code log options" src="//learning-services-media.brightcove.com/doc-assets/player-development/architecture/proxy-API-call/debugging-code-log-options.png" /></figure>
    <p>옵션 개체에 포함된 내용은 수행하려는 작업에 따라 다르지만 다음과 같은 몇 가지 기본 사항은 항상 존재합니다.</p>
    <ul>
      <li>계정 ID입니다. 이것은 별도의 속성이거나 API endPoint URL의 일부일 수 있습니다.</li>
      <li>프록시를 저장하는 위치에 따라 달라지는 프록시에 대한 URL입니다.</li>
      <li>예를 들어 HTTP 메소드 유형<code translate="No">GET</code> , <code translate="No">POST</code>또는<code translate="No">PATCH</code> .</li>
      <li>API에서 실제 요청을 수행하기 위해 프록시에서 사용하는 API 끝점 URL입니다. 예를 들면 다음과 같습니다.
        <pre class="line-numbers">
	<code class="language-html" translate="No">https://players.api.brightcove.com/v2/accounts/57838016001/players
	https://edge.api.brightcove.com/playback/v1/accounts/1752604059001/videos/5842800655001
	https://analytics.api.brightcove.com/v1/alltime/accounts/1752604059001/videos/4093643993001</code></pre>
      </li>
    </ul>
    <p>API 요청에 따라 옵션 객체에 다른 속성이 필요할 수 있습니다. 다음은 특정 계정의 모든 플레이어에 대한 요청을 만들기 위해 옵션 개체를 기록할 때 콘솔에 표시되는 내용의 예입니다.</p>
    <figure class="bcls-figure"><img class="bcls-image" alt="debugging options simple" src="//learning-services-media.brightcove.com/doc-assets/player-development/architecture/proxy-API-call/debugging-options-simple.png" /></figure>
    <p>다음은 플레이어를 업데이트할 때 사용되는 좀 더 복잡한 로그 옵션 개체입니다.</p>
    <figure class="bcls-figure"><img class="bcls-image" alt="debugging options" src="//learning-services-media.brightcove.com/doc-assets/player-development/architecture/proxy-API-call/debugging-options.png" /></figure>
    <h3>반환된 데이터 보기</h3>
    <p>반환되는 내용은 요청한 데이터와 오류 반환 여부에 따라 다릅니다. 그러나 무엇을 반환하든 관계없이 어떤 데이터가 반환되는지 확인하고 싶을 것입니다. 이를 수행하는 간단한 방법은 콘솔에 원시 로그를 기록하는 것입니다. <code translate="No">response</code>호출 직후의 데이터<code translate="No">makeRequest</code>기능:</p>
    <figure class="bcls-figure"><img class="bcls-image" alt="debugging code log options" src="//learning-services-media.brightcove.com/doc-assets/player-development/architecture/proxy-API-call/debugging-code-log-response.png" /></figure>
    <p>반환되는 것은 거의 무한한 가능성이 있지만 다음은 몇 가지 예입니다. 첫 번째는 계정의 모든 플레이어를 요청할 때 응답의 시작을 보여줍니다.</p>
    <figure class="bcls-figure"><img class="bcls-image" alt="debugging response on players request" src="//learning-services-media.brightcove.com/doc-assets/player-development/architecture/proxy-API-call/debugging-response-multiple-players.png" /></figure>
    <aside class="bcls-aside bcls-aside--tip">이것은 응답을 볼 때 플레이어 정보가<code translate="No">items</code> .</aside>
    <p>다음은 다음을 사용하여 플레이어를 업데이트한 후의 응답입니다. <code translate="No">PATCH</code> HTTP 방법:</p>
    <figure class="bcls-figure"><img class="bcls-image" alt="debugging response on player patch" src="//learning-services-media.brightcove.com/doc-assets/player-development/architecture/proxy-API-call/debugging-response-on-player-patch.png" /></figure>
    <p>다음은 첫 번째 응답의 데이터를 보다 멋지게 형식화한 보기입니다.</p>
    <pre class="line-numbers">
	<code class="language-json" translate="No">{
		"id": "1OHQdsTAr",
		"preview_url": "http://preview-players.brightcove.net/v2/accounts/.../master/index.html",
		"preview_embed_in_page": "http://preview-players.brightcove.net/v2/accounts/.../master/in_page.embed",
		"preview_embed_code": "&lt;iframe src='//preview-players.brightcove.net/v2/accounts/.../master/index.html' ...&gt;&lt;/iframe&gt;"
	}</code></pre>
    <p>마지막으로 오류가 발생했을 때의 매우 귀중한 응답입니다. 이 경우 적절한 자격 증명 없이 계정이 사용되었습니다.</p>
    <figure class="bcls-figure"><img class="bcls-image" alt="debugging response on error" src="//learning-services-media.brightcove.com/doc-assets/player-development/architecture/proxy-API-call/debugging-response-on-error.png" /></figure>
  </section>
  <h3>기타 문제 해결 팁</h3>
  <p>문제가 있는 경우 찾을 수 있는 다른 사항이 있습니다.</p>
  <dl>
    <dt>응답 없음</dt>
    <dd>빈 응답을 받는지 확인해야 할 몇 가지 사항이 있습니다.
      <ul>
        <li>API 참조를 확인하여 요청이 응답을 반환하는지 확인하십시오. 일부는 내용이 없는 201 또는 204 응답만 반환합니다(특히 DELETE 요청 뿐만 아니라). 이 경우를 처리하려면 코드를 조정해야 합니다.</li>
        <li>브라우저에서 개발자 도구의 네트워크 섹션을 확인하여 프록시에 대한 성공적인 호출을 확인하십시오(해당 서버를 일시적으로 사용할 수 없음).
          <figure class="bcls-figure"><img class="bcls-image" alt="Developer Tools Network Section" src="https://learning-services-media.brightcove.com/doc-assets/node/18132-learning-guide-rest-apis/developer-tools-network.png" />
            <figcaption class="bcls-caption--image">개발자 도구 네트워크 섹션</figcaption>
          </figure>
        </li>
      </ul>
    </dd>
    <dt>응답을 볼 수 있지만 시도할 때<code translate="No">JSON.parse()</code>예외가 발생합니다.</dt>
    <dd>여기에 몇 가지 가능성이 있습니다.
      <ul>
        <li>이전 항목 참조 - 빈 문자열을 구문 분석하려고 하면 JSON 예외가 발생합니다.</li>
        <li>
          <p>응답을 보고 JSON 문자열인지 확인합니다( <code translate="No">{</code>또는<code translate="No">[</code> ). 요청이 JSON을 반환하지 않을 수 있는 몇 가지 경우가 있습니다. <span translate="No">애널리틱스 API</span>예를 들어<code translate="No">format</code>매개변수<code translate="No">csv</code>또는<code translate="No">xlxs</code> . 다시 말하지만, 이러한 종류의 요청을 하는 경우 JSON이 아닌 응답을 처리하도록 코드를 조정해야 합니다.</p>
        </li>
        <li>대부분의 경우 API에서 반환하는 오류는 JSON 형식이기도 하지만 오류가 일반 텍스트 또는 HTML로 반환되는 몇 가지 예외가 있습니다.</li>
      </ul>
    </dd>
  </dl>
  <section class="bcls-section">
    <h2 id="Proxy_code">프록시 코드</h2>
    <p>앞에서 언급했듯이 프록시는 선택한 언어로 작성할 수 있습니다. Brightcove API 문서 예제는 PHP로 작성된 프록시를 사용합니다. 프록시 구현은 언어에 따라 다르기 때문에 아래의 PHP 코드는 이 문서에서 자세히 분석하지 않습니다.</p>
    <p>프록시에서 제공하는 기본 기능에는 다음이 포함되어야 합니다.</p>
    <ol>
      <li>클라이언트 요청을 수락합니다.</li>
      <li>받기<strong>인증 토큰</strong> OAuth API에서.</li>
      <li>인증 토큰과 데이터 요청(엔드포인트)을 원하는 API로 보냅니다.</li>
      <li>API에서 데이터를 다시 받습니다.</li>
      <li>데이터를 다시 클라이언트로 보냅니다.</li>
    </ol>
    <pre class="line-numbers">
	<code class="language-javascript" translate="No">&lt;?php
	/**
	 * proxy for Brightcove RESTful APIs
	 * gets an access token, makes the request, and returns the response
	 * Accessing:
	 *     (note you should **always** access the proxy via HTTPS)
	 *     Method: POST
	 *     request body (accessed via php://input) is a JSON object with the following properties
	 *
	 * {string} url - the URL for the API request
	 * {string} [requestType=GET] - HTTP method for the request
	 * {string} [requestBody] - JSON data to be sent with write requests
	 * {string} [client_id] - OAuth2 client id with sufficient permissions for the request
	 * {string} [client_secret] - OAuth2 client secret with sufficient permissions for the request
	 *
	 * Example:
	 * {
	 *    "url": "https://cms.api.brightcove.com/v1/accounts/57838016001/video",
	 *    "requestType": "PATCH",
	 *    "client_id": "0072bebf-0616-442c-84de-7215bb176061",
	 *    "client_secret": "7M0vMete8vP_Dmb9oIRdUN1S5lrqTvgtVvdfsasd",
	 *    "requestBody": "{\"description\":\"Updated video description\"}"
	 * }
	 *
	 * if client_id and client_secret are not included in the request, default values will be used
	 *
	 * @returns {string} $response - JSON response received from the API
	 */
	
	// security checks
	// if you want to do some basic security checks, such as checking the origin of the
	// the request against some white list, this would be a good place to do it
	// CORS enablement and other headers
	header("Access-Control-Allow-Origin: *");
	header("Content-type: application/json");
	header("X-Content-Type-Options: nosniff");
	header("X-XSS-Protection");
	
	// default account values
	// if you work on one Brightcove account, put in the values below
	// if you do not provide defaults, the client id, and client secret must
	// be sent in the request body for each request
	$default_client_id     = 'YOUR_CLIENT_ID';
	$default_client_secret = 'YOUR_CLIENT_SECRET';
	
	// get request body
	$requestData = json_decode(file_get_contents('php://input'));
	
	// set up access token request
	// check to see if client id and secret were passed with the request
	// and if so, use them instead of defaults
	if (isset($requestData-&gt;client_id)) {
			$client_id = $requestData-&gt;client_id;
	}
	
	if (isset($requestData-&gt;client_secret)) {
			$client_secret = $requestData-&gt;client_secret;
	}
	
	$auth_string = "{$client_id}:{$client_secret}";
	
	// make the request to get an access token
	$request = "https://oauth.brightcove.com/v4/access_token?grant_type=client_credentials";
	$curl          = curl_init($request);
	curl_setopt($curl, CURLOPT_USERPWD, $auth_string);
	curl_setopt($curl, CURLOPT_POST, TRUE);
	curl_setopt($curl, CURLOPT_RETURNTRANSFER, TRUE);
	curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, FALSE);
	curl_setopt($curl, CURLOPT_HTTPHEADER, array(
		'Content-type: application/x-www-form-urlencoded',
	));
	
	$response = curl_exec($curl);
	$curl_info = curl_getinfo($curl);
	$php_log = array(
		"php_error_info" =&gt; $curl_info
	);
	$curl_error = curl_error($curl);
	
	curl_close($curl);
	
	// Check for errors
	// it's useful to log as much info as possible for debugging
	if ($response === FALSE) {
		log_error($php_log, $curl_error);
	}
	
	// Decode the response and get access token
	$responseData = json_decode($response, TRUE);
	$access_token = $responseData["access_token"];
	// get request type or default to GET
	$method = "GET";
	if ($requestData-&gt;requestType) {
			$method = $requestData-&gt;requestType;
	}
	
	// get the URL and authorization info from the form data
	$request = $requestData-&gt;url;
	// check for a request body sent with the request
	if (isset($requestData-&gt;requestBody)) {
		$data = $requestData-&gt;requestBody;
	}
		$curl = curl_init($request);
		curl_setopt($curl, CURLOPT_RETURNTRANSFER, TRUE);
		curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, FALSE);
		curl_setopt($curl, CURLOPT_HTTPHEADER, array(
			'Content-type: application/json',
			"Authorization: Bearer {$access_token}"
		));
		switch ($method)
			{
				case "POST":
					curl_setopt($curl, CURLOPT_POST, TRUE);
					if ($requestData-&gt;requestBody) {
						curl_setopt($curl, CURLOPT_POSTFIELDS, $data);
					}
					break;
				case "PUT":
					// don't use CURLOPT_PUT; it is not reliable
					curl_setopt($curl, CURLOPT_CUSTOMREQUEST, $method);
					if ($requestData-&gt;requestBody) {
						curl_setopt($curl, CURLOPT_POSTFIELDS, $data);
					}
					break;
				case "PATCH":
					curl_setopt($curl, CURLOPT_CUSTOMREQUEST, $method);
					if ($requestData-&gt;requestBody) {
						curl_setopt($curl, CURLOPT_POSTFIELDS, $data);
					}
					break;
				case "DELETE":
					curl_setopt($curl, CURLOPT_CUSTOMREQUEST, $method);
					if ($requestData-&gt;requestBody) {
						curl_setopt($curl, CURLOPT_POSTFIELDS, $data);
					}
					break;
				default:
					// GET request, nothing to do;
			}
		$response = curl_exec($curl);
		$curl_info = curl_getinfo($curl);
		$php_log = array(
			"php_error_info" =&gt; $curl_info
		);
		$curl_error = curl_error($curl);
		curl_close($curl);
	
	// Check for errors and log them if any
	// note that logging will fail unless
	// the file log.txt exists in the same
	// directory as the proxy and is writable
	
	if ($response === FALSE) {
		log_error($php_log, $curl_error);
	}
	
	function log_error($php_log, $curl_error) {
		$logEntry = "\nError:\n". "\n".date("Y-m-d H:i:s"). " UTC \n" .$curl_error. "\n".json_encode($php_log, JSON_PRETTY_PRINT);
		$logFileLocation = "log.txt";
		$fileHandle      = fopen($logFileLocation, 'a') or die("-1");
		fwrite($fileHandle, $logEntry);
		fclose($fileHandle);
		echo "Error: there was a problem with your API call"+
		die(json_encode($php_log, JSON_PRETTY_PRINT));
	}
	
	// return the response to the AJAX caller
	echo $response;
	?&gt;</code></pre>
    <p>프록시 서버에 대한 전체 코드가 위에 표시되어 있지만 GitHub 리포지토리에도 있습니다. <a href="https://github.com/BrightcoveLearning/sample-proxy-apps">샘플 프록시 앱</a>에서<strong> PHP</strong>폴더.</p>
  </section>
  <section class="bcls-section">
    <h2 id="Example_2">예제 2</h2>
    <p>이 두 번째 예는 앞에서 설명한 것보다 더 복잡합니다. 이 예에서는 재생 목록의 계정에서 가장 인기 있는 10개의 동영상을 표시합니다. 코드의 주요 단계는 다음과 같습니다.</p>
    <ol>
      <li>요청<span translate="No">애널리틱스 API</span>계정에서 가장 많은 조회수를 기록한 10개의 동영상. 이 단계에는 콜백 함수를 사용한 비동기 호출이 포함됩니다.</li>
      <li>반환에서<span translate="No">애널리틱스 API</span>데이터에서 비디오 ID만 추출하여 배열에 배치합니다. 반환된 데이터에서 ID를 추출하기 위해 도우미 함수가 작성되었습니다.</li>
      <li>배열의 ID 목록에 있는 각 비디오에 대한 완전한 비디오 객체를 요청하십시오. 이 단계에는 배열을 반복하고 다음을 사용하여 비디오 객체를 요청하는 작업이 포함됩니다. <code translate="No">player.catalog.getVideo()</code> . 물론 여기에는 다음을 사용하는 여러 비동기 호출이 포함됩니다. <code translate="No">catalog</code> . 도우미 함수는 ID를 기반으로 비디오 개체를 검색하고 개체를 배열에 배치하기 위해 작성되었습니다.</li>
      <li>재생 목록 지원 플레이어의 재생 목록에 비디오 개체 배열을 배치합니다.</li>
    </ol>
    <p>이제 API를 호출하는 방법에 대한 많은 개념과 특정 코드에 익숙하므로 API를 호출하는 코드만<code translate="No">makeRequest()</code>기능이 자세히 나와있습니다.</p>
    <ul>
      <li>2호선: 를 불러<code translate="No">makeRequest()</code>함수는 익명으로 정의된 콜백 함수(노란색으로 강조 표시됨)와 함께 성공적인 REST API 호출에 필요한 옵션을 인수로 전달합니다. 이것은 위에서 친숙하게 들릴 것입니다. 매우 중요한 것은, <code translate="No">makeRequest()</code>호출된 함수는 이전 예에서 사용된 것과 똑같은 함수입니다. 코드에서 동일한 작업을 수행할 수 있습니다. NS <code translate="No">makeRequest()</code>함수는 Brightcove REST API에 대한 모든 호출과 함께 재사용되도록 작성되었습니다. <aside class="bcls-aside bcls-aside--tip">NS <code translate="No">mostWatchedVideos</code>매개 변수에는 콜백 함수가 사용될 때 검색된 값이 할당됩니다. <code translate="No">makeRequest()</code>기능.</aside>
      </li>
      <li>3호선: JSON 구문 분석된 반환 데이터를 저장할 변수를 만듭니다.</li>
      <li>5호선: 반환된 데이터를 구문 분석하여 if 문자열에서 개체로 변환합니다.</li>
      <li>7번 라인: 도우미 함수를 사용하여 반환된 데이터에서 비디오 ID를 추출합니다. 불행히도, <span translate="No">애널리틱스 API</span>전체 비디오 개체를 반환하지 않으므로 전체 개체에 액세스하려면 ID가 필요합니다.</li>
      <li>9-12행: 를 불러<code translate="No">getVideoData</code>콜백 함수를 사용하여 채우는 도우미 함수<code translate="No">videoObjects</code>전달된 ID를 기반으로 하는 배열입니다.</li>
      <li>11번 행: 비디오 개체 배열로 재생 목록을 채웁니다.</li>
    </ul>
    <pre class="line-numbers">
	<code class="language-javascript" translate="No">// +++ Make the <span translate="No">CMS API</span> request to get matching video IDs +++
	makeRequest(options, <span class="bcls-highlight">function(mostWatchedVideos) {
		var JSONmostWatchedVideos;
		// Convert response string into JSON
		JSONmostWatchedVideos = JSON.parse(mostWatchedVideos);
		// Extract the needed video IDs into an array
		videoData = extractVideoData(JSONmostWatchedVideos);
		// Get video objects based on array of video IDs
		getVideoData(videoData, function(videoObjects) {
			// Add the most watched videos list to the player as a playlist
			myPlayer.playlist(videoObjects);
		});</span>
	});</code></pre>
    <h3>전체 코드 목록</h3>
    <p>완전한 작동 예제는 다음 CodePen에 있습니다. <a href="https://codepen.io/team/rcrooks1969/pen/zRzZNG/">재생 목록에서 가장 많이 본 동영상</a> .</p>
  </section>
</article>